/*! ngTagsInput v3.2.0 License: MIT */
!function (a) { "use strict"; function b(a, b, c, d, e, f, g) { "ngInject"; function h(a, b, c, e) { var g = {}, h = function (b) { return f.safeToString(b[a.displayProperty]) }, i = function (b, c) { b[a.displayProperty] = c }, j = function (b) { var e = h(b), i = e && e.length >= a.minLength && e.length <= a.maxLength && a.allowedTagsPattern.test(e) && !f.findInObjectArray(g.items, b, a.keyProperty || a.displayProperty); return d.when(i && c({ $tag: b })).then(f.promisifyValue) }, k = function (a) { return d.when(e({ $tag: a })).then(f.promisifyValue) }; return g.items = [], g.addText = function (a) { var b = {}; return i(b, a), g.add(b) }, g.addTextArr = function (a) { a.forEach(function (a) { return g.addText(a) }) }, g.add = function (c) { var d = h(c); return a.replaceSpacesWithDashes && (d = f.replaceSpacesWithDashes(d)), i(c, d), j(c).then(function () { g.items.push(c), b.trigger("tag-added", { $tag: c }) }).catch(function () { d && b.trigger("invalid-tag", { $tag: c }) }) }, g.remove = function (a) { var c = g.items[a]; return k(c).then(function () { return g.items.splice(a, 1), g.clearSelection(), b.trigger("tag-removed", { $tag: c }), c }) }, g.select = function (a) { a < 0 ? a = g.items.length - 1 : a >= g.items.length && (a = 0), g.index = a, g.selected = g.items[a] }, g.selectPrior = function () { g.select(--g.index) }, g.selectNext = function () { g.select(++g.index) }, g.removeSelected = function () { return g.remove(g.index) }, g.clearSelection = function () { g.selected = null, g.index = -1 }, g.getItems = function () { return a.useStrings ? g.items.map(h) : g.items }, g.clearSelection(), g } function i(a) { return -1 !== g.SUPPORTED_INPUT_TYPES.indexOf(a) } return { restrict: "E", require: "ngModel", scope: { tags: "=ngModel", text: "=?", templateScope: "=?", tagClass: "&", onTagAdding: "&", onTagAdded: "&", onInvalidTag: "&", onTagRemoving: "&", onTagRemoved: "&", onTagClicked: "&" }, replace: !1, transclude: !0, templateUrl: "ngTagsInput/tags-input.html", controller: ["$scope", "$element", "$attrs", function (a, b, c) { a.events = f.simplePubSub(), a.options = e.load("tagsInput", b, c, a.events, { template: [String, "ngTagsInput/tag-item.html"], type: [String, "text", i], placeholder: [String, "Add a tag"], tabindex: [Number, null], removeTagSymbol: [String, String.fromCharCode(215)], replaceSpacesWithDashes: [Boolean, !0], minLength: [Number, 3], maxLength: [Number, g.MAX_SAFE_INTEGER], addOnEnter: [Boolean, !0], addOnSpace: [Boolean, !1], addOnComma: [Boolean, !0], addOnBlur: [Boolean, !0], addOnPaste: [Boolean, !1], pasteSplitPattern: [RegExp, /,/], allowedTagsPattern: [RegExp, /.+/], enableEditingLastTag: [Boolean, !1], minTags: [Number, 0], maxTags: [Number, g.MAX_SAFE_INTEGER], displayProperty: [String, "text"], keyProperty: [String, ""], allowLeftoverText: [Boolean, !1], addFromAutocompleteOnly: [Boolean, !1], spellcheck: [Boolean, !0], allowDblclickToEdit: [Boolean, !1], inputSplitPattern: [RegExp, null], useStrings: [Boolean, !1] }), a.tagList = new h(a.options, a.events, f.handleUndefinedResult(a.onTagAdding, !0), f.handleUndefinedResult(a.onTagRemoving, !0)), this.registerAutocomplete = function () { return { addTag: function (b) { return a.tagList.add(b) }, getTags: function () { return a.tagList.items }, getCurrentTagText: function () { return a.newTag.text() }, getOptions: function () { return a.options }, getTemplateScope: function () { return a.templateScope }, on: function (b, c) { return a.events.on(b, c, !0), this } } }, this.registerTagItem = function () { return { getOptions: function () { return a.options }, removeTag: function (b) { a.disabled || a.tagList.remove(b) } } } }], link: function (d, e, h, i) { var j = [g.KEYS.enter, g.KEYS.comma, g.KEYS.space, g.KEYS.backspace, g.KEYS.delete, g.KEYS.left, g.KEYS.right], k = d.tagList, l = d.events, m = d.options, o = e.find("input"), p = ["minTags", "maxTags", "allowLeftoverText"], q = function () { i.$setValidity("maxTags", k.items.length <= m.maxTags), i.$setValidity("minTags", k.items.length >= m.minTags), i.$setValidity("leftoverText", !(!d.hasFocus && !m.allowLeftoverText) || !d.newTag.text()) }, r = function () { a(function () { o[0].focus() }) }; i.$isEmpty = function (a) { return !a || !a.length }, d.isEditing = !1, d.editingTag = { text: function (a) { if (!angular.isDefined(a)) return d.editingText || ""; d.editingText = a, l.trigger("edit-input-change", a) }, invalid: null }, d.newTag = { text: function (a) { if (!angular.isDefined(a)) return d.text || ""; d.text = a, l.trigger("input-change", a) }, invalid: null }, d.track = function (a) { return a[m.keyProperty || m.displayProperty] }, d.getTagClass = function (a, b) { var c = a === k.selected; return [d.tagClass({ $tag: a, $index: b, $selected: c }), { selected: c }] }, d.$watch("tags", function (a) { if (a) { if (k.items = f.makeObjectArray(a, m.displayProperty), m.useStrings) return; d.tags = k.items } else k.items = [] }), d.$watch("tags.length", function () { q(), i.$validate() }), h.$observe("disabled", function (a) { d.disabled = a }), d.eventHandlers = { input: { keydown: function (a) { l.trigger("input-keydown", a) }, focus: function () { d.hasFocus || (d.hasFocus = !0, l.trigger("input-focus")) }, blur: function () { a(function () { var a = b.prop("activeElement"), c = a === o[0], f = e[0].contains(a); !c && f || (d.hasFocus = !1, l.trigger("input-blur")) }) }, editBlur: function (a, b) { l.trigger("edit-input-blur", b) }, paste: function (a) { a.getTextData = function () { var b = a.clipboardData || a.originalEvent && a.originalEvent.clipboardData; return b ? b.getData("text/plain") : c.clipboardData.getData("Text") }, l.trigger("input-paste", a) } }, host: { click: function () { d.disabled || r() } }, tag: { click: function (a) { l.trigger("tag-clicked", { $tag: a }) }, dblclick: function (a) { l.trigger("tag-dblclicked", a) } } }, l.on("tag-added", d.onTagAdded).on("invalid-tag", d.onInvalidTag).on("tag-removed", d.onTagRemoved).on("tag-clicked", d.onTagClicked).on("tag-dblclicked", function (a) { m.allowDblclickToEdit && (d.editingTag.text(a.text), a.editable = !0, d.isEditing = !0) }).on("tag-added", function () { d.newTag.text("") }).on("tag-added tag-removed", function () { d.tags = k.getItems(), i.$setDirty(), r() }).on("invalid-tag", function () { d.newTag.invalid = !0 }).on("option-change", function (a) { -1 !== p.indexOf(a.name) && q() }).on("input-change", function () { k.clearSelection(), d.newTag.invalid = null }).on("input-focus", function () { e.triggerHandler("focus"), i.$setValidity("leftoverText", !0) }).on("input-blur", function () { if (m.addOnBlur && !m.addFromAutocompleteOnly) { var a = d.newTag.text().split(m.inputSplitPattern); k.addTextArr(a) } e.triggerHandler("blur"), q() }).on("edit-input-blur", function (a) { var b = d.editingTag.text(), c = b.split(m.inputSplitPattern), e = c.shift(); a.text = e, k.addTextArr(c), a.editable = !1, d.isEditing = !1, r() }).on("edit-input-change", function () { k.clearSelection(), d.editingTag.invalid = null }).on("input-keydown", function (a) { var b, c = a.keyCode; if (!f.isModifierOn(a) && -1 !== j.indexOf(c)) { var h = (b = {}, n(b, g.KEYS.enter, m.addOnEnter), n(b, g.KEYS.comma, m.addOnComma), n(b, g.KEYS.space, m.addOnSpace), b), i = !m.addFromAutocompleteOnly && h[c], l = (c === g.KEYS.backspace || c === g.KEYS.delete) && k.selected, o = c === g.KEYS.backspace && 0 === d.newTag.text().length && m.enableEditingLastTag && !d.isEditing, p = (c === g.KEYS.backspace || c === g.KEYS.left || c === g.KEYS.right) && 0 === d.newTag.text().length && !m.enableEditingLastTag; if (i) { if (d.isEditing) return void e.find("input")[0].blur(); var q = d.newTag.text().split(m.inputSplitPattern); k.addTextArr(q) } else o ? (k.selectPrior(), k.removeSelected().then(function (a) { a && d.newTag.text(a[m.displayProperty]) })) : l ? k.removeSelected() : p && (c === g.KEYS.left || c === g.KEYS.backspace ? k.selectPrior() : c === g.KEYS.right && k.selectNext()); (i || p || l || o) && a.preventDefault() } }).on("input-paste", function (a) { if (m.addOnPaste) { var b = a.getTextData(), c = b.split(m.pasteSplitPattern); c.length > 1 && (k.addTextArr(c), a.preventDefault()) } }) } } } function c(a) { "ngInject"; return { restrict: "E", require: "^tagsInput", template: '<ng-include src="$$template"></ng-include>', scope: { $scope: "=scope", data: "=" }, link: function (b, c, d, e) { var f = e.registerTagItem(), g = f.getOptions(); b.$$template = g.template, b.$$removeTagSymbol = g.removeTagSymbol, b.$getDisplayText = function () { return a.safeToString(b.data[g.displayProperty]) }, b.$removeTag = function () { f.removeTag(b.$index) }, b.$watch("$parent.$index", function (a) { b.$index = a }) } } } function d(a, b, c, d, e, f, g) { "ngInject"; function h(a, b, c) { var e = {}, g = null, h = function () { return b.tagsInput.keyProperty || b.tagsInput.displayProperty }, i = function (a, c) { return a.filter(function (a) { return !f.findInObjectArray(c, a, h(), function (a, c) { return b.tagsInput.replaceSpacesWithDashes && (a = f.replaceSpacesWithDashes(a), c = f.replaceSpacesWithDashes(c)), f.defaultComparer(a, c) }) }) }; return e.reset = function () { g = null, e.items = [], e.visible = !1, e.index = -1, e.selected = null, e.query = null }, e.show = function () { b.selectFirstMatch ? e.select(0) : e.selected = null, e.visible = !0 }, e.load = f.debounce(function (c, j) { e.query = c; var k = d.when(a({ $query: c })); g = k, k.then(function (a) { k === g && (a = f.makeObjectArray(a.data || a, h()), a = i(a, j), e.items = a.slice(0, b.maxResultsToShow), e.items.length > 0 ? e.show() : e.reset()) }) }, b.debounceDelay), e.selectNext = function () { e.select(++e.index) }, e.selectPrior = function () { e.select(--e.index) }, e.select = function (a) { a < 0 ? a = e.items.length - 1 : a >= e.items.length && (a = 0), e.index = a, e.selected = e.items[a], c.trigger("suggestion-selected", a) }, e.reset(), e } function i(a, b) { var c = a.find("li").eq(b), d = c.parent(), e = c.prop("offsetTop"), f = c.prop("offsetHeight"), g = d.prop("clientHeight"), h = d.prop("scrollTop"); e < h ? d.prop("scrollTop", e) : e + f > g + h && d.prop("scrollTop", e + f - g) } return { restrict: "E", require: "^tagsInput", scope: { source: "&", matchClass: "&" }, templateUrl: "ngTagsInput/auto-complete.html", controller: ["$scope", "$element", "$attrs", function (a, b, c) { a.events = f.simplePubSub(), a.options = e.load("autoComplete", b, c, a.events, { template: [String, "ngTagsInput/auto-complete-match.html"], debounceDelay: [Number, 100], minLength: [Number, 3], highlightMatchedText: [Boolean, !0], maxResultsToShow: [Number, 10], loadOnDownArrow: [Boolean, !1], loadOnEmpty: [Boolean, !1], loadOnFocus: [Boolean, !1], selectFirstMatch: [Boolean, !0], displayProperty: [String, ""] }), a.suggestionList = new h(a.source, a.options, a.events), this.registerAutocompleteMatch = function () { return { getOptions: function () { return a.options }, getQuery: function () { return a.suggestionList.query } } } }], link: function (a, b, c, d) { var e = [g.KEYS.enter, g.KEYS.tab, g.KEYS.escape, g.KEYS.up, g.KEYS.down], h = a.suggestionList, j = d.registerAutocomplete(), k = a.options, l = a.events; k.tagsInput = j.getOptions(); var m = function (a) { return a && a.length >= k.minLength || !a && k.loadOnEmpty }; a.templateScope = j.getTemplateScope(), a.addSuggestionByIndex = function (b) { h.select(b), a.addSuggestion() }, a.addSuggestion = function () { var a = !1; return h.selected && (j.addTag(angular.copy(h.selected)), h.reset(), a = !0), a }, a.track = function (a) { return a[k.tagsInput.keyProperty || k.tagsInput.displayProperty] }, a.getSuggestionClass = function (b, c) { var d = b === h.selected; return [a.matchClass({ $match: b, $index: c, $selected: d }), { selected: d }] }, j.on("tag-added tag-removed invalid-tag input-blur", function () { h.reset() }).on("input-change", function (a) { m(a) ? h.load(a, j.getTags()) : h.reset() }).on("input-focus", function () { var a = j.getCurrentTagText(); k.loadOnFocus && m(a) && h.load(a, j.getTags()) }).on("input-keydown", function (b) { var c = b.keyCode, d = !1; if (!f.isModifierOn(b) && -1 !== e.indexOf(c)) return h.visible ? c === g.KEYS.down ? (h.selectNext(), d = !0) : c === g.KEYS.up ? (h.selectPrior(), d = !0) : c === g.KEYS.escape ? (h.reset(), d = !0) : c !== g.KEYS.enter && c !== g.KEYS.tab || (d = a.addSuggestion()) : c === g.KEYS.down && a.options.loadOnDownArrow && (h.load(j.getCurrentTagText(), j.getTags()), d = !0), d ? (b.preventDefault(), b.stopImmediatePropagation(), !1) : void 0 }), l.on("suggestion-selected", function (a) { i(b, a) }) } } } function e(a, b) { "ngInject"; return { restrict: "E", require: "^autoComplete", template: '<ng-include src="$$template"></ng-include>', scope: { $scope: "=scope", data: "=" }, link: function (c, d, e, f) { var g = f.registerAutocompleteMatch(), h = g.getOptions(); c.$$template = h.template, c.$index = c.$parent.$index, c.$highlight = function (c) { return h.highlightMatchedText && (c = b.safeHighlight(c, g.getQuery())), a.trustAsHtml(c) }, c.$getDisplayText = function () { return b.safeToString(c.data[h.displayProperty || h.tagsInput.displayProperty]) } } } } function f(a) { "ngInject"; return { restrict: "A", require: "ngModel", link: function (b, c, d, e) { var f = a.getTextAutosizeThreshold(), g = angular.element('<span class="input"></span>'); g.css("display", "none").css("visibility", "hidden").css("width", "auto").css("white-space", "pre"), c.parent().append(g); var h = function (a) { var b = a, e = void 0; return angular.isString(b) && 0 === b.length && (b = d.placeholder), b && (g.text(b), g.css("display", ""), e = g.prop("offsetWidth"), g.css("display", "none")), c.css("width", e ? e + f + "px" : ""), a }; e.$parsers.unshift(h), e.$formatters.unshift(h), d.$observe("placeholder", function (a) { e.$modelValue || h(a) }) } } } function g() { return function (a, b, c) { a.$watch(c.tiBindAttrs, function (a) { angular.forEach(a, function (a, b) { c.$set(b, a) }) }, !0) } } function h(a, b) { "ngInject"; return { scope: {}, link: function (c, d, e) { c.selectAll = !1; var f = b(e.tiSelectall), g = function () { a(function () { d[0].focus(), d[0].select() }) }; c.$watch(f, function (a) { !0 === a && g(), c.selectAll = a }) } } } function i() { return function (a, b, c, d, e) { e(function (a) { b.append(a) }) } } function j() { "ngInject"; var a = this, b = {}, c = {}, d = 3; this.setDefaults = function (c, d) { return b[c] = d, a }, this.setActiveInterpolation = function (b, d) { return c[b] = d, a }, this.setTextAutosizeThreshold = function (b) { return d = b, a }, this.$get = ["$interpolate", function (a) { var e, f = (e = {}, n(e, String, function (a) { return a.toString() }), n(e, Number, function (a) { return parseInt(a, 10) }), n(e, Boolean, function (a) { return "true" === a.toLowerCase() }), n(e, RegExp, function (a) { return new RegExp(a) }), e); return { load: function (d, e, g, h, i) { var j = function () { return !0 }, k = {}; return angular.forEach(i, function (i, l) { var m = i[0], n = i[1], o = i[2] || j, p = f[m], q = function () { var a = b[d] && b[d][l]; return angular.isDefined(a) ? a : n }, r = function (a) { k[l] = a && o(a) ? p(a) : q() }; c[d] && c[d][l] ? g.$observe(l, function (a) { r(a), h.trigger("option-change", { name: l, newValue: a }) }) : r(g[l] && a(g[l])(e.scope())) }), k }, getTextAutosizeThreshold: function () { return d } } }] } function k(a, b) { "ngInject"; var c = {}; return c.debounce = function (b, c) { var d = void 0; return function () { for (var e = arguments.length, f = Array(e), g = 0; g < e; g++)f[g] = arguments[g]; a.cancel(d), d = a(function () { b.apply(null, f) }, c) } }, c.makeObjectArray = function (a, b) { return !angular.isArray(a) || 0 === a.length || angular.isObject(a[0]) ? a : a.map(function (a) { return n({}, b, a) }) }, c.findInObjectArray = function (a, b, d, e) { var f = null; return e = e || c.defaultComparer, a.some(function (a) { if (e(a[d], b[d])) return f = a, !0 }), f }, c.defaultComparer = function (a, b) { return c.safeToString(a).toLowerCase() === c.safeToString(b).toLowerCase() }, c.safeHighlight = function (a, b) { if (a = c.encodeHTML(a), !(b = c.encodeHTML(b))) return a; var d = new RegExp("&[^;]+;|" + function (a) { return a.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1") }(b), "gi"); return a.replace(d, function (a) { return a.toLowerCase() === b.toLowerCase() ? "<em>" + a + "</em>" : a }) }, c.safeToString = function (a) { return angular.isUndefined(a) || null === a ? "" : a.toString().trim() }, c.encodeHTML = function (a) { return c.safeToString(a).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") }, c.handleUndefinedResult = function (a, b) { return function () { var c = a.apply(null, arguments); return angular.isUndefined(c) ? b : c } }, c.replaceSpacesWithDashes = function (a) { return c.safeToString(a).replace(/\s/g, "-") }, c.isModifierOn = function (a) { return a.shiftKey || a.ctrlKey || a.altKey || a.metaKey }, c.promisifyValue = function (a) { return a = !!angular.isUndefined(a) || a, b[a ? "when" : "reject"]() }, c.simplePubSub = function () { var a = {}; return { on: function (b, c, d) { return b.split(" ").forEach(function (b) { a[b] || (a[b] = []), (d ? [].unshift : [].push).call(a[b], c) }), this }, trigger: function (b, d) { return (a[b] || []).every(function (a) { return c.handleUndefinedResult(a, !0)(d) }), this } } }, c } function l(a) { a.put("ngTagsInput/auto-complete-match.html", '<span ng-bind-html="$highlight($getDisplayText())"></span>'), a.put("ngTagsInput/auto-complete.html", '<div class="autocomplete" ng-if="suggestionList.visible"><ul class="suggestion-list"><li class="suggestion-item" ng-repeat="item in suggestionList.items track by track(item)" ng-class="getSuggestionClass(item, $index)" ng-click="addSuggestionByIndex($index)" ng-mouseenter="suggestionList.select($index)"><ti-autocomplete-match scope="templateScope" data="::item"></ti-autocomplete-match></li></ul></div>'), a.put("ngTagsInput/tag-item.html", '<span ng-bind="$getDisplayText()"></span> <a class="remove-button" ng-click="$removeTag()" ng-bind="::$$removeTagSymbol"></a>'), a.put("ngTagsInput/tags-input.html", '<div class="host" tabindex="-1" ng-click="eventHandlers.host.click()" ti-transclude-append><div class="tags" ng-class="{focused: hasFocus}"><ul class="tag-list"><li ng-repeat="tag in tagList.items track by track(tag)" ng-class="getTagClass(tag, $index)" ng-click="eventHandlers.tag.click(tag)" ng-dblclick="eventHandlers.tag.dblclick(tag)"><ti-tag-item class="tag-item" scope="templateScope" data="tag" ng-hide="tag.editable"></ti-tag-item><input class="input" autocomplete="off" ng-model="editingTag.text" ng-model-options="{getterSetter: true}" ng-click="$event.stopPropagation();" ng-if="tag.editable" ng-keydown="eventHandlers.input.keydown($event)" ng-blur="eventHandlers.input.editBlur($event,tag)" ng-paste="eventHandlers.input.paste($event)" ng-disabled="disabled" ng-class="{\'invalid-tag\': editingTag.invalid}" ti-selectall="true" ti-autosize=""></li></ul><input class="input" autocomplete="off" ng-model="newTag.text" ng-model-options="{getterSetter: true}" ng-keydown="eventHandlers.input.keydown($event)" ng-focus="eventHandlers.input.focus($event)" ng-blur="eventHandlers.input.blur($event)" ng-paste="eventHandlers.input.paste($event)" ng-trim="false" ng-class="{\'invalid-tag\': newTag.invalid}" ng-disabled="disabled" ti-bind-attrs="{type: options.type, placeholder: options.placeholder, tabindex: options.tabindex, spellcheck: options.spellcheck}" ti-autosize></div></div>') } var m = { KEYS: { backspace: 8, tab: 9, enter: 13, escape: 27, space: 32, up: 38, down: 40, left: 37, right: 39, delete: 46, comma: 188 }, MAX_SAFE_INTEGER: 9007199254740991, SUPPORTED_INPUT_TYPES: ["text", "email", "url"] }, n = function (a, b, c) { return b in a ? Object.defineProperty(a, b, { value: c, enumerable: !0, configurable: !0, writable: !0 }) : a[b] = c, a }; b.$inject = ["$timeout", "$document", "$window", "$q", "tagsInputConfig", "tiUtil", "tiConstants"], c.$inject = ["tiUtil"], d.$inject = ["$document", "$timeout", "$sce", "$q", "tagsInputConfig", "tiUtil", "tiConstants"], e.$inject = ["$sce", "tiUtil"], f.$inject = ["tagsInputConfig"], h.$inject = ["$timeout", "$parse"], k.$inject = ["$timeout", "$q"], l.$inject = ["$templateCache"], a.module("ngTagsInput", []).directive("tagsInput", b).directive("tiTagItem", c).directive("autoComplete", d).directive("tiAutocompleteMatch", e).directive("tiAutosize", f).directive("tiBindAttrs", g).directive("tiTranscludeAppend", i).directive("tiSelectall", h).factory("tiUtil", k).constant("tiConstants", m).provider("tagsInputConfig", j).run(l) }(angular);
//# sourceMappingURL=ng-tags-input.min.js.map